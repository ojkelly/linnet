import {
    ResolverTemplate,
    ResolverTemplates,
    ResolverMappingType,
} from "./types";
import {
    DataSource,
    DataSourceTemplate,
    DataSourceTemplates,
    DataSourceDynamoDBConfig,
} from "../dataSources/dataSources";
import {
    visit,
    parse,
    buildSchema,
    GraphQLField,
    GraphQLType,
    ObjectTypeDefinitionNode,
    StringValueNode,
    DocumentNode,
    GraphQLSchema,
    GraphQLNamedType,
} from "graphql";
import { Config } from "../../common/types";
import {
    Edge,
    EdgePrinciple,
} from "../schemaProcessing/steps/generateArtifacts/extractEdges";
const pkg = require("../../../../package.json");
import { generateLambdaDataSourceTemplate } from "../dataSources/lambda";
import * as createGenerator from "./lambda/create";
// import * as deleteGenerator from "./lambda/delete";
// import * as deleteManyGenerator from "./lambda/delete";
// import * as updateGenerator from "./lambda/update";
// import * as updateManyGenerator from "./lambda/updateMany";
import * as upsertGenerator from "./lambda/upsert";

// $util.error($util.toJson($ctx))

/**
 * Generate a resolver template
 * @param options
 */
function generateLambdaResolverTemplate({
    dataSource,
    typeName,
    fieldName,
    fieldType,
    namedType,
    resolverType,
    edges,
    config,
}: {
    dataSource: DataSourceTemplate;
    typeName: string;
    fieldName: string;
    namedType: string;
    fieldType: GraphQLField<any, any, any>;
    resolverType: string;
    edges?: Edge[];
    config: Config;
}): ResolverTemplate | any {
    const date = new Date();
    const headerString: string = `## Generated by ${pkg.name}
## Version: ${pkg.version}
## ${date.toISOString()}

## This is an array of all the linnet system fields
#set($linnetFields = ["linnet:dataType","linnet:edge","linnet:namedType"])
`;
    const lambdaDataSource = generateLambdaDataSourceTemplate({
        config,
        name: `Mutation`,
        resolverType,
    });

    return {
        dataSourceName: lambdaDataSource.name,
        typeName,
        fieldName,
        responseMappingTemplate: generateResponseTemplate({
            fieldName,
            fieldType,
            dataSource,
            namedType,
            resolverType,
            edges,
            headerString,
        }),
        requestMappingTemplate: generateRequestTemplate({
            fieldName,
            fieldType,
            namedType,
            dataSource,
            resolverType,
            edges,
            headerString,
        }),
    };
}

/**
 * Get the edge that matches the type.field
 * @param options
 */
function getEdgeForField({
    typeName,
    fieldName,
    edges,
}: {
    typeName: string;
    fieldName: string;
    edges: Edge[];
}): Edge | null {
    // console.log({ typeName, fieldName });
    if (Array.isArray(edges)) {
        const foundEdge = edges.find((edge: Edge) => {
            if (typeName === edge.typeName && fieldName === edge.field) {
                return true;
            }

            return false;
        });
        if (typeof foundEdge !== "undefined") {
            return foundEdge;
        }
    }
    // If we found nothing we return undefined
    return null;
}

/**
 * Generate DynamoDB request template
 * @param options
 */
function generateRequestTemplate({
    fieldName,
    fieldType,
    namedType,
    dataSource,
    resolverType,
    edges,
    headerString,
}: {
    fieldName: string;
    namedType: string;
    fieldType: GraphQLField<any, any, any>;
    dataSource: DataSourceTemplate;
    resolverType: string;
    edges?: Edge[];
    headerString: string;
}): string {
    switch (resolverType) {
        // [ Mutation ]-----------------------------------------------------------------------------
        case "create":
            return createGenerator.generateRequestTemplate({
                fieldName,
                fieldType,
                namedType,
                dataSource,
                resolverType,
                edges,
                headerString,
            });
        case "upsert":
            return upsertGenerator.generateRequestTemplate({
                fieldName,
                fieldType,
                namedType,
                dataSource,
                resolverType,
                edges,
                headerString,
            });
        // case "update":
        //     return updateGenerator.generateRequestTemplate({
        //         fieldName,
        //         fieldType,
        //         namedType,
        //         dataSource,
        //         resolverType,
        //         edges,
        //         headerString,
        //     });
        // case "updateMany":
        //     return updateManyGenerator.generateRequestTemplate({
        //         fieldName,
        //         fieldType,
        //         namedType,
        //         dataSource,
        //         resolverType,
        //         edges,
        //         headerString,
        //     });

        default:
    }
}

/**
 * Generate Lambda response template
 * @param options
 */
function generateResponseTemplate({
    fieldName,
    fieldType,
    namedType,
    dataSource,
    resolverType,
    edges,
    headerString,
}: {
    fieldName: string;
    namedType: string;
    fieldType: GraphQLField<any, any, any>;
    dataSource: DataSourceTemplate;
    resolverType: string;
    edges: Edge[];
    headerString: string;
}): string {
    // Add error handling to the repsonse templates
    const header: string = `${headerString}

#if ($ctx.error)
  $util.appendError($ctx.error.message, $ctx.error.type, null, $ctx.result.data.unprocessedKeys)
#end
`;
    switch (resolverType) {
        // [ Mutation ]-----------------------------------------------------------------------------
        case "create":
            return createGenerator.generateResponseTemplate({
                fieldName,
                fieldType,
                namedType,
                dataSource,
                resolverType,
                edges,
                headerString: header,
            });
        case "upsert":
            return upsertGenerator.generateResponseTemplate({
                fieldName,
                fieldType,
                namedType,
                dataSource,
                resolverType,
                edges,
                headerString: header,
            });
        // case "update":
        //     return updateGenerator.generateResponseTemplate({
        //         fieldName,
        //         fieldType,
        //         namedType,
        //         dataSource,
        //         resolverType,
        //         edges,
        //         headerString: header,
        //     });
        // case "updateMany":
        //     return updateManyGenerator.generateResponseTemplate({
        //         fieldName,
        //         fieldType,
        //         namedType,
        //         dataSource,
        //         resolverType,
        //         edges,
        //         headerString: header,
        //     });
        default:
    }
}

export { generateLambdaResolverTemplate };
