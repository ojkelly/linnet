import {
  ResolverTemplate,
  ResolverTemplates,
  ResolverMappingType,
} from "./types";
import {
  DataSource,
  DataSourceTemplate,
  DataSourceTemplates,
  DataSourceDynamoDBConfig,
} from "../dataSources/dataSources";
import {
  visit,
  parse,
  buildSchema,
  GraphQLField,
  GraphQLType,
  ObjectTypeDefinitionNode,
  StringValueNode,
  DocumentNode,
  GraphQLSchema,
  GraphQLNamedType,
} from "graphql";
import { Config } from "../../common/types";
import {
  Edge,
  EdgePrinciple,
} from "../schemaProcessing/steps/generateArtifacts/extractEdges";
const pkg = require("../../../../package.json");
import { generateLambdaDataSourceTemplate } from "../dataSources/lambda";
import * as createGenerator from "./lambda/create";
import * as deleteGenerator from "./lambda/delete";
import * as deleteManyGenerator from "./lambda/delete";
import * as updateGenerator from "./lambda/update";
import * as updateManyGenerator from "./lambda/updateMany";

import * as connection from "./lambda/connection";
import * as connectionPlural from "./lambda/connectionPlural";
import * as query from "./lambda/QUERY";
import * as plural from "./lambda/plural";

// $util.error($util.toJson($ctx))

/**
 * Generate a resolver template
 * @param options
 */
function generateLambdaResolverTemplate({
  dataSource,
  typeName,
  field,
  fieldName,
  fieldType,
  namedType,
  resolverType,
  edges,
  config,
}: {
  dataSource: DataSourceTemplate;
  typeName: string;
  field: string;
  fieldName: string;
  namedType: string;
  fieldType: GraphQLField<any, any, any>;
  resolverType: string;
  edges?: Edge[];
  config: Config;
}): ResolverTemplate | any {
  const date = new Date();
  const headerString: string = `## Generated by ${pkg.name}
## Version: ${pkg.version}
## ${date.toISOString()}

## NamedType: ${namedType}
## ResolverType: ${resolverType}
## FieldName: ${fieldName}

## This is an array of all the linnet system fields
#set($linnetFields = ["linnet:dataType","linnet:edge","linnet:namedType","linnet:ttl"])
`;
  const lambdaDataSource = generateLambdaDataSourceTemplate({
    config,
    name: `Mutation`,
    resolverType,
  });

  return {
    dataSourceName: lambdaDataSource.name,
    typeName,
    fieldName,
    responseMappingTemplate: generateResponseTemplate({
      field,
      fieldName,
      fieldType,
      dataSource,
      namedType,
      resolverType,
      edges,
      headerString,
    }),
    requestMappingTemplate: generateRequestTemplate({
      field,
      fieldName,
      fieldType,
      namedType,
      dataSource,
      resolverType,
      edges,
      headerString,
    }),
  };
}

/**
 * Get the edge that matches the type.field
 * @param options
 */
function getEdgeForField({
  typeName,
  fieldName,
  edges,
}: {
  typeName: string;
  fieldName: string;
  edges: Edge[];
}): Edge | null {
  // console.log({ typeName, fieldName });
  if (Array.isArray(edges)) {
    const foundEdge = edges.find((edge: Edge) => {
      if (typeName === edge.typeName && fieldName === edge.field) {
        return true;
      }

      return false;
    });
    if (typeof foundEdge !== "undefined") {
      return foundEdge;
    }
  }
  // If we found nothing we return undefined
  return null;
}

/**
 * Generate DynamoDB request template
 * @param options
 */
function generateRequestTemplate({
  field,
  fieldName,
  fieldType,
  namedType,
  dataSource,
  resolverType,
  edges,
  headerString,
}: {
  field: string;
  fieldName: string;
  namedType: string;
  fieldType: GraphQLField<any, any, any>;
  dataSource: DataSourceTemplate;
  resolverType: string;
  edges?: Edge[];
  headerString: string;
}): string {
  switch (resolverType) {
    // [ Query ]-----------------------------------------------------------------------------
    case "query":
      return query.generateRequestTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "plural":
      return plural.generateRequestTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "connectionPlural":
      return connectionPlural.generateRequestTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "connection":
      return connection.generateRequestTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    // [ Mutation ]-----------------------------------------------------------------------------
    case "create":
      return createGenerator.generateRequestTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "update":
      return updateGenerator.generateRequestTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "updateMany":
      return updateManyGenerator.generateRequestTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "delete":
      return deleteGenerator.generateRequestTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "deleteMany":
      return deleteManyGenerator.generateRequestTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });

    default:
  }
}

/**
 * Generate Lambda response template
 * @param options
 */
function generateResponseTemplate({
  field,
  fieldName,
  fieldType,
  namedType,
  dataSource,
  resolverType,
  edges,
  headerString,
}: {
  field: string;
  fieldName: string;
  namedType: string;
  fieldType: GraphQLField<any, any, any>;
  dataSource: DataSourceTemplate;
  resolverType: string;
  edges: Edge[];
  headerString: string;
}): string {
  // Add error handling to the repsonse templates
  const header: string = `${headerString}

#if ($ctx.error)
  $util.appendError($ctx.error.message, $ctx.error.type, null, $ctx.result.data.unprocessedKeys)
#end
`;
  switch (resolverType) {
    // [ Query ]-----------------------------------------------------------------------------
    case "query":
      return query.generateResponseTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "plural":
      return plural.generateResponseTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "connectionPlural":
      return connectionPlural.generateResponseTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    case "connection":
      return connection.generateResponseTemplate({
        field,
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString,
      });
    // [ Mutation ]-----------------------------------------------------------------------------
    case "create":
      return createGenerator.generateResponseTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString: header,
      });
    case "update":
      return updateGenerator.generateResponseTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString: header,
      });
    case "updateMany":
      return updateManyGenerator.generateResponseTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString: header,
      });
    case "delete":
      return deleteGenerator.generateResponseTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString: header,
      });
    case "deleteMany":
      return deleteManyGenerator.generateResponseTemplate({
        fieldName,
        fieldType,
        namedType,
        dataSource,
        resolverType,
        edges,
        headerString: header,
      });
    default:
  }
}

export { generateLambdaResolverTemplate };
